#---------- (1) Variables ----------
# LJ inter-species sigma: sigma_ij
# 1: small monomer, 2: large monomer, 3: crowder
variable sig1 equal 1.0

# LJ inter-sepcies r_cutoff: r_cutoff_ij
variable ljRcut equal 1.12246205 # lj/cutoff distance: 2^(1/6)
variable cutoff11 equal ${sig1}*${ljRcut}
variable cutoff22 equal ${sig2}*${ljRcut}
variable cutoff33 equal ${sig3}*${ljRcut}

#--------------------- (3) Neighbor Lists ---------------------
variable vskin equal 0.3 # v stands for Verlet
neighbor ${vskin} bin # using different ghost cutoffs  
#neigh_modify    delay 0 every 1 check yes
#neigh_modify collection/type 3 1 2 3 # 1: small mons, 2: large mons, 3: crowders
## Communication settings
# ghost cutoff = neighbor cutoff = pairwise force cutoff + vskin
# cutoff/multi(=Rcut) overrides ghost cutoff only if former is larger 
# than later; please see below for cutoff/multi setting.
# Whithout "multi" option in "neighbor":
# ghost cutoff = max(neighbor cutoff) = max(pairwise force cutoff) + vskin # So we have:
# ghost cutoff = max(neighbor cutoff) = cutoffLL + vskin
# By changing to "multi" and setting communication/ghosy cutoff accordingly,
# we have:
#variable gRcut1 equal ${cutoff11}+${vskin} # ghost cutoff: small monomer
#variable gRcut2 equal ${cutoff22}+${vskin} # ghost cutoff: large monomer 
#variable gRcut3 equal ${cutoff33}+${vskin} # ghost cutoff: crowders
#comm_modify mode multi cutoff/multi 1 ${gRcut1} cutoff/multi 2 ${gRcut2} cutoff/multi 3 ${gRcut3}

#--------------------- (7) Settings ---------------------
#---------- Equilibration/Method of integration of equation of motion ----------
#---------- Brownian dynamics for all particles ----------
fix F_langevin all langevin 1.0 1.0 10.0 ${randseed}

#--------------------- (8) Run a simulation ---------------------
#---------- Production phase
#Reset some settings
fix F_nve all nve
fix F_recenter bug recenter 0.0 0.0 0.0 shift all units box
timestep ${run_dt}
thermo_style multi
thermo 10000

dump D_bug bug atom  ${bug_dump} al${sig2}nl${n_big}ml${mass2}ns${n_small}ac${sig3}nc${n_crowd}l${l}dt${run_dt}bdump${bug_dump}adump${all_dump}ens${i}.linear.bug.restart.lammpstrj
dump_modify D_bug scale no

variable fname string input.lmp
variable j loop ${nloop} pad
        label dump_loop
        dump D_all all atom ${all_dump} al${sig2}nl${n_big}ml${mass2}ns${n_small}ac${sig3}nc${n_crowd}l${l}dt${run_dt}bdump${bug_dump}adump${all_dump}ens${i}.j${j}.linear.all.restart.lammpstrj
        dump_modify D_all scale no pad 2
        restart 1000000 ./restarts/restart.${i}
        if "$j == ${nloop}" then "run 8000000" else "run 5000000"
        undump D_all
        next j
        jump ${fname} dump_loop # input.lmp is the input script itself to prevent any issues related to stdin and SELF.
undump D_bug
write_data al${sig2}nl${n_big}ml${mass2}ns${n_small}ac${sig3}nc${n_crowd}l${l}dt${run_dt}bdump${bug_dump}adump${all_dump}ens${i}.linear.all.data pair ij
write_restart ./restart_after.i${i}