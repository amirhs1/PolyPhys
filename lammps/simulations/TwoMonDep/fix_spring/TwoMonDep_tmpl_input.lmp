
# ---------- Simulation Initialization ----------
units           lj
dimension       3
boundary        p p p                       # Periodic boundary conditions
atom_style      atomic
region          cube block -${hl} ${hl} -${hl} ${hl} -${hl} ${hl} units box
create_box      2 cube                 # Create a box with two atom types

# ---------- Create Atoms ----------
variable        z_1 equal (${sig1}/2)+${sd}    # Position of first monomer
variable        z_2 equal -1*((${sig1}/2)+${sd})  # Position of second monomer
variable        r_12 equal ${sig1}+${sd} # center tpo center distance

create_atoms    1 single 0 0 ${z_1}         # Create first monomer
create_atoms    1 single 0 0 ${z_2}         # Create second monomer
create_atoms    2 random ${n2} ${randseed} cube units box   # Create crowders

# ---------- Neighbor Lists ----------
variable        vskin equal 0.3             # Verlet skin distance
neighbor        ${vskin} bin
neigh_modify    delay 0 every 1 check yes

# ---------- Define Groups ----------
group           monomer1 id 1               # First monomer
group           monomer2 id 2               # Second monomer
group           bug type 1                  # All monomers
group           crowders type 2             # All crowders

# ---------- Masses ----------
variable        m1 equal ${sig1}^3          # Mass of monomers
variable        m2 equal ${sig2}^3          # Mass of crowders

mass            1 ${m1}
mass            2 ${m2}

# ---------- Fix Monomer Positions and Compute Forces ----------

fix             F_spr monomer1 spring couple monomer2 100.0 NULL NULL &
                ${r_12} 0.0
fix_modify      F_spr energy yes

compute         e_m1_c monomer1 group/group crowders pair yes boundary no
compute         e_m2_c monomer2 group/group crowders pair yes boundary no
compute         e_m1_m2 monomer2 group/group monomer1 pair yes boundary no

# ---------- Interatomic Potential ----------
variable        ljRcut equal 1.122462     # LJ cutoff distance
variable        cutoff11 equal ${sig1}*${ljRcut}
variable        cutoff22 equal ${sig2}*${ljRcut}

pair_style      lj/cut ${ljRcut}
pair_coeff      1 1 1.0 ${sig1} ${cutoff11}
pair_coeff      2 2 1.0 ${sig2} ${cutoff22}
pair_modify     mix geometric shift yes

# ---------- Equilibration ----------
variable        scale1 equal ${m1}/${sig1}
variable        scale2 equal ${m2}/${sig2}
fix             F_langevin all langevin 1 1 10 ${randseed} &
                scale 1 ${scale1} scale 2 ${scale2} tally yes

# Part 1: Equilibration with NVE/limit
fix             F_nve all nve/limit 0.01
thermo          100000

thermo_style    custom step temp press etotal pe ke epair evdwl ecouple &
                econserve f_F_spr f_F_spr[1] f_F_spr[2] f_F_spr[3] f_F_spr[4] &
                c_e_m1_c c_e_m1_c[1] c_e_m1_c[2] c_e_m1_c[3] c_e_m2_c &
                c_e_m2_c[1] c_e_m2_c[2] c_e_m2_c[3] c_e_m1_m2 c_e_m1_m2[1] &
                c_e_m1_m2[2] c_e_m1_m2[3]

thermo_modify   colname f_F_spr e_spr colname f_F_spr[1] fx_spr &
                colname f_F_spr[2] fy_spr colname f_F_spr[3] fz_spr &
                colname f_F_spr[4] fmag_spr & 
                colname c_e_m1_c e_m1_c colname c_e_m1_c[1] fx_m1_c & 
                colname c_e_m1_c[2] fy_m1_c colname c_e_m1_c[3] fz_m1_c &
                colname c_e_m2_c e_m2_c colname c_e_m2_c[1] fx_m2_c &
                colname c_e_m2_c[2] fy_m2_c colname c_e_m2_c[3] fz_m2_c &
                colname c_e_m1_m2 e_m1_m2 colname c_e_m1_m2[1] fx_m1_m2 &
                colname c_e_m1_m2[2] fy_m1_m2 colname c_e_m1_m2[3] fz_m1_m2

timestep        0.005
run             500000
write_restart   ./restart_before.i${i}
unfix           F_nve

# ---------- Production Run ----------
fix             F_nve all nve
reset_timestep  0
timestep        0.0005
thermo_modify   warn default
thermo          2000
dump            D_bug bug atom 2000 ${simname}.bug.lammpstrj
dump_modify     D_bug scale no

variable        fname string input.lmp
variable        j loop 20 pad # for loop
label           dump_loop # the body of the for loop
dump            D_all all atom 5000 &
                ${simname}.j${j}.all.lammpstrj
dump_modify     D_all scale no pad 2
restart         1000000 ./restarts/restart.${i}
run             1000000
undump          D_all
next            j
jump            ${fname} dump_loop # end of the body of thefor loop

undump          D_bug
write_data      ${simname}.all.data pair ij
write_restart   ./restart_after.i${i}